{"version":3,"file":"useViewportColumns.js","sourceRoot":"","sources":["../../src/hooks/useViewportColumns.ts"],"names":[],"mappings":"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","sourcesContent":["import { useMemo } from 'react';\n\nimport { CalculatedColumn, Column } from '../types';\nimport { getColumnMetrics } from '../utils';\nimport { DataGridProps } from '../DataGrid';\nimport { ValueFormatter } from '../formatters';\n\ntype SharedDataGridProps<R, K extends keyof R, SR> = Pick<DataGridProps<R, K, SR>,\n  | 'defaultColumnOptions'\n  | 'rowGrouper'\n>;\n\ninterface ViewportColumnsArgs<R, K extends keyof R, SR> extends SharedDataGridProps<R, K, SR> {\n  rawColumns: readonly Column<R, SR>[];\n  rawGroupBy?: readonly string[];\n  viewportWidth: number;\n  scrollLeft: number;\n  columnWidths: ReadonlyMap<string, number>;\n}\n\nexport function useViewportColumns<R, K extends keyof R, SR>({\n  rawColumns,\n  columnWidths,\n  viewportWidth,\n  scrollLeft,\n  defaultColumnOptions,\n  rawGroupBy,\n  rowGrouper\n}: ViewportColumnsArgs<R, K, SR>) {\n  const minColumnWidth = defaultColumnOptions?.minWidth ?? 80;\n  const defaultFormatter = defaultColumnOptions?.formatter ?? ValueFormatter;\n  const defaultSortable = defaultColumnOptions?.sortable ?? false;\n  const defaultResizable = defaultColumnOptions?.resizable ?? false;\n\n  const { columns, lastFrozenColumnIndex, totalColumnWidth, totalFrozenColumnWidth, groupBy } = useMemo(() => {\n    return getColumnMetrics<R, SR>({\n      rawColumns,\n      minColumnWidth,\n      viewportWidth,\n      columnWidths,\n      defaultSortable,\n      defaultResizable,\n      defaultFormatter,\n      rawGroupBy: rowGrouper ? rawGroupBy : undefined\n    });\n  }, [columnWidths, defaultFormatter, defaultResizable, defaultSortable, minColumnWidth, rawColumns, rawGroupBy, rowGrouper, viewportWidth]);\n\n  const [colOverscanStartIdx, colOverscanEndIdx] = useMemo((): [number, number] => {\n    // get the viewport's left side and right side positions for non-frozen columns\n    const viewportLeft = scrollLeft + totalFrozenColumnWidth;\n    const viewportRight = scrollLeft + viewportWidth;\n    // get first and last non-frozen column indexes\n    const lastColIdx = columns.length - 1;\n    const firstUnfrozenColumnIdx = Math.min(lastFrozenColumnIndex + 1, lastColIdx);\n\n    // skip rendering non-frozen columns if the frozen columns cover the entire viewport\n    if (viewportLeft >= viewportRight) {\n      return [firstUnfrozenColumnIdx, firstUnfrozenColumnIdx];\n    }\n\n    // get the first visible non-frozen column index\n    let colVisibleStartIdx = firstUnfrozenColumnIdx;\n    while (colVisibleStartIdx < lastColIdx) {\n      const { left, width } = columns[colVisibleStartIdx];\n      // if the right side of the columnn is beyond the left side of the available viewport,\n      // then it is the first column that's at least partially visible\n      if (left + width > viewportLeft) {\n        break;\n      }\n      colVisibleStartIdx++;\n    }\n\n    // get the last visible non-frozen column index\n    let colVisibleEndIdx = colVisibleStartIdx;\n    while (colVisibleEndIdx < lastColIdx) {\n      const { left, width } = columns[colVisibleEndIdx];\n      // if the right side of the column is beyond or equal to the right side of the available viewport,\n      // then it the last column that's at least partially visible, as the previous column's right side is not beyond the viewport.\n      if (left + width >= viewportRight) {\n        break;\n      }\n      colVisibleEndIdx++;\n    }\n\n    const colOverscanStartIdx = Math.max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1);\n    const colOverscanEndIdx = Math.min(lastColIdx, colVisibleEndIdx + 1);\n\n    return [colOverscanStartIdx, colOverscanEndIdx];\n  }, [columns, lastFrozenColumnIndex, scrollLeft, totalFrozenColumnWidth, viewportWidth]);\n\n  const viewportColumns = useMemo((): readonly CalculatedColumn<R, SR>[] => {\n    const viewportColumns: CalculatedColumn<R, SR>[] = [];\n    for (let colIdx = 0; colIdx <= colOverscanEndIdx; colIdx++) {\n      const column = columns[colIdx];\n\n      if (colIdx < colOverscanStartIdx && !column.frozen) continue;\n      viewportColumns.push(column);\n    }\n\n    return viewportColumns;\n  }, [colOverscanEndIdx, colOverscanStartIdx, columns]);\n\n  return { columns, viewportColumns, totalColumnWidth, lastFrozenColumnIndex, totalFrozenColumnWidth, groupBy };\n}\n"]}