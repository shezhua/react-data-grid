{"version":3,"file":"useViewportRows.js","sourceRoot":"","sources":["../../src/hooks/useViewportRows.ts"],"names":[],"mappings":"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","sourcesContent":["import { useMemo } from 'react';\n\nimport { GroupRow, GroupByDictionary, Dictionary } from '../types';\nconst RENDER_BACTCH_SIZE = 8;\n\ninterface ViewportRowsArgs<R, SR> {\n  rawRows: readonly R[];\n  rowHeight: number;\n  clientHeight: number;\n  scrollTop: number;\n  groupBy: readonly string[];\n  rowGrouper?: (rows: readonly R[], columnKey: string) => Dictionary<readonly R[]>;\n  expandedGroupIds?: ReadonlySet<unknown>;\n}\n\nexport function useViewportRows<R, SR>({\n  rawRows,\n  rowHeight,\n  clientHeight,\n  scrollTop,\n  groupBy,\n  rowGrouper,\n  expandedGroupIds\n}: ViewportRowsArgs<R, SR>) {\n  const [groupedRows, rowsCount] = useMemo(() => {\n    if (groupBy.length === 0 || !rowGrouper) return [undefined, rawRows.length];\n\n    const groupRows = (rows: readonly R[], [groupByKey, ...remainingGroupByKeys]: readonly string[], startRowIndex: number): [GroupByDictionary<R>, number] => {\n      let groupRowsCount = 0;\n      const groups: GroupByDictionary<R> = {};\n      for (const [key, childRows] of Object.entries(rowGrouper(rows, groupByKey))) {\n        // Recursively group each parent group\n        const [childGroups, childRowsCount] = remainingGroupByKeys.length === 0\n          ? [childRows, childRows.length]\n          : groupRows(childRows, remainingGroupByKeys, startRowIndex + groupRowsCount + 1); // 1 for parent row\n        groups[key] = { childRows, childGroups, startRowIndex: startRowIndex + groupRowsCount };\n        groupRowsCount += childRowsCount + 1; // 1 for parent row\n      }\n\n      return [groups, groupRowsCount];\n    };\n\n    return groupRows(rawRows, groupBy, 0);\n  }, [groupBy, rowGrouper, rawRows]);\n\n  const [rows, allGroupRows] = useMemo(() => {\n    const allGroupRows = new Set<unknown>();\n    if (!groupedRows) return [rawRows, allGroupRows];\n\n    const flattenedRows: Array<R | GroupRow<R>> = [];\n    const expandGroup = (rows: GroupByDictionary<R> | readonly R[], parentId: string | undefined, level: number): void => {\n      if (Array.isArray(rows)) {\n        flattenedRows.push(...rows);\n        return;\n      }\n      Object.keys(rows).forEach((groupKey, posInSet, keys) => {\n        // TODO: should users have control over the generated key?\n        const id = parentId !== undefined ? `${parentId}__${groupKey}` : groupKey;\n        const isExpanded = expandedGroupIds?.has(id) ?? false;\n        const { childRows, childGroups, startRowIndex } = (rows as GroupByDictionary<R>)[groupKey]; // https://github.com/microsoft/TypeScript/issues/17002\n\n        const groupRow: GroupRow<R> = {\n          id,\n          parentId,\n          groupKey,\n          isExpanded,\n          childRows,\n          level,\n          posInSet,\n          startRowIndex,\n          setSize: keys.length\n        };\n        flattenedRows.push(groupRow);\n        allGroupRows.add(groupRow);\n\n        if (isExpanded) {\n          expandGroup(childGroups, id, level + 1);\n        }\n      });\n    };\n\n    expandGroup(groupedRows, undefined, 0);\n    return [flattenedRows, allGroupRows];\n  }, [expandedGroupIds, groupedRows, rawRows]);\n\n  const isGroupRow = <R>(row: unknown): row is GroupRow<R> => allGroupRows.has(row);\n\n  const overscanThreshold = 4;\n  const rowVisibleStartIdx = Math.floor(scrollTop / rowHeight);\n  const rowVisibleEndIdx = Math.min(rows.length - 1, Math.floor((scrollTop + clientHeight) / rowHeight));\n  const rowOverscanStartIdx = Math.max(0, Math.floor((rowVisibleStartIdx - overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n  const rowOverscanEndIdx = Math.min(rows.length - 1, Math.ceil((rowVisibleEndIdx + overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n\n  return {\n    rowOverscanStartIdx,\n    rowOverscanEndIdx,\n    rows,\n    rowsCount,\n    isGroupRow\n  };\n}\n"]}